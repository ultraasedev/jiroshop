const logger = require('../utils/logger');

// Types d'erreurs connus
const knownErrors = {
    ETELEGRAM: 'Erreur Telegram API',
    EMONGO: 'Erreur de base de donn√©es',
    EPAYMENT: 'Erreur de paiement',
    EVALIDATION: 'Erreur de validation',
    EACCESS: 'Erreur d\'acc√®s',
    EFILE: 'Erreur de fichier',
    ETIMEDOUT: 'D√©lai d\'attente d√©pass√©',
    ENOTFOUND: 'Ressource non trouv√©e'
};

const errorHandler = async (err, ctx) => {
    try {
        // Logger l'erreur avec le contexte
        logger.error('Erreur globale:', {
            error: {
                name: err.name,
                message: err.message,
                stack: err.stack
            },
            context: {
                updateType: ctx.updateType,
                userId: ctx.from?.id,
                chatId: ctx.chat?.id,
                messageId: ctx.message?.message_id
            }
        });

        // Analyser l'erreur
        const errorAnalysis = analyzeError(err);

        // Enregistrer l'erreur pour analyse
        await storeError(errorAnalysis, ctx);

        // Notifier les admins si n√©cessaire
        if (errorAnalysis.severity === 'high') {
            await notifyAdmins(errorAnalysis, ctx);
        }

        // Envoyer une r√©ponse appropri√©e √† l'utilisateur
        await sendUserResponse(errorAnalysis, ctx);

        // Nettoyer si n√©cessaire
        await cleanup(errorAnalysis, ctx);

    } catch (handlingError) {
        // En cas d'erreur dans le gestionnaire d'erreurs lui-m√™me
        logger.error('Erreur dans le gestionnaire d\'erreurs:', handlingError);
        
        // Tenter une derni√®re r√©ponse simple
        try {
            await ctx.reply('Une erreur inattendue est survenue. Veuillez r√©essayer plus tard.');
        } catch (finalError) {
            logger.error('√âchec de la r√©ponse finale:', finalError);
        }
    }
};

// Analyser l'erreur pour d√©terminer le type et la s√©v√©rit√©
function analyzeError(error) {
    let errorType = 'UNKNOWN';
    let severity = 'low';
    let userMessage = 'Une erreur est survenue. Veuillez r√©essayer.';
    let needsCleanup = false;

    // D√©terminer le type d'erreur
    for (const [key, description] of Object.entries(knownErrors)) {
        if (error.message.includes(key) || error.name.includes(key)) {
            errorType = key;
            break;
        }
    }

    // Configurer la r√©ponse selon le type d'erreur
    switch (errorType) {
        case 'ETELEGRAM':
            if (error.code === 403) {
                severity = 'low';
                userMessage = 'Impossible d\'envoyer le message. Le bot a peut-√™tre √©t√© bloqu√©.';
            } else if (error.code === 429) {
                severity = 'medium';
                userMessage = 'Trop de requ√™tes. Veuillez patienter quelques minutes.';
            } else {
                severity = 'high';
                userMessage = 'Erreur de communication avec Telegram. R√©essayez plus tard.';
            }
            break;

        case 'EMONGO':
            severity = 'high';
            userMessage = 'Erreur de service. Veuillez r√©essayer plus tard.';
            needsCleanup = true;
            break;

        case 'EPAYMENT':
            severity = 'high';
            userMessage = 'Erreur lors du traitement du paiement. Veuillez r√©essayer ou contacter le support.';
            break;

        case 'EVALIDATION':
            severity = 'low';
            userMessage = 'Les donn√©es fournies ne sont pas valides. Veuillez v√©rifier et r√©essayer.';
            break;

        case 'EACCESS':
            severity = 'medium';
            userMessage = 'Vous n\'avez pas les permissions n√©cessaires pour cette action.';
            break;

        case 'EFILE':
            severity = 'medium';
            userMessage = 'Erreur lors du traitement du fichier. Veuillez r√©essayer.';
            needsCleanup = true;
            break;

        case 'ETIMEDOUT':
            severity = 'low';
            userMessage = 'La requ√™te a pris trop de temps. Veuillez r√©essayer.';
            break;

        case 'ENOTFOUND':
            severity = 'low';
            userMessage = 'La ressource demand√©e n\'existe pas.';
            break;

        default:
            severity = 'medium';
            needsCleanup = true;
    }

    return {
        type: errorType,
        severity,
        originalError: error,
        userMessage,
        needsCleanup,
        timestamp: new Date()
    };
}

// Stocker l'erreur pour analyse
async function storeError(errorAnalysis, ctx) {
    try {
        const ErrorLog = require('../models/ErrorLog');
        await ErrorLog.create({
            type: errorAnalysis.type,
            severity: errorAnalysis.severity,
            message: errorAnalysis.originalError.message,
            stack: errorAnalysis.originalError.stack,
            context: {
                userId: ctx.from?.id,
                chatId: ctx.chat?.id,
                updateType: ctx.updateType,
                state: ctx.session?.state
            },
            timestamp: errorAnalysis.timestamp
        });
    } catch (error) {
        logger.error('Erreur lors du stockage de l\'erreur:', error);
    }
}

// Notifier les administrateurs
async function notifyAdmins(errorAnalysis, ctx) {
    try {
        const User = require('../models/User');
        const admins = await User.find({ role: 'admin' });

        const message = 
            `üö® *Erreur Critique D√©tect√©e*\n\n` +
            `Type: ${errorAnalysis.type}\n` +
            `S√©v√©rit√©: ${errorAnalysis.severity}\n` +
            `Message: ${errorAnalysis.originalError.message}\n` +
            `Utilisateur: ${ctx.from?.id}\n` +
            `Chat: ${ctx.chat?.id}\n` +
            `Date: ${errorAnalysis.timestamp.toISOString()}\n\n` +
            `Action requise !`;

        for (const admin of admins) {
            try {
                await ctx.telegram.sendMessage(admin.telegramId, message, {
                    parse_mode: 'Markdown'
                });
            } catch (error) {
                logger.error('Erreur lors de la notification admin:', {
                    adminId: admin.telegramId,
                    error
                });
            }
        }
    } catch (error) {
        logger.error('Erreur lors de la notification des admins:', error);
    }
}

// Envoyer une r√©ponse appropri√©e √† l'utilisateur
// Fonction modifi√©e pour envoyer une r√©ponse appropri√©e √† l'utilisateur
async function sendUserResponse(errorAnalysis, ctx) {
    try {
        // Message de base
        let message = errorAnalysis.userMessage;

        // Ajouter un ID de r√©f√©rence pour le support
        const errorRef = generateErrorReference();
        message += `\n\nR√©f√©rence: ${errorRef}`;

        // Ajouter des boutons selon le type d'erreur
        const buttons = [];

        switch (errorAnalysis.type) {
            case 'EPAYMENT':
                buttons.push([
                    { text: 'üí≥ R√©essayer le paiement', callback_data: 'retry_payment' },
                    { text: 'üìû Contacter le support', callback_data: 'contact_support' }
                ]);
                break;

            case 'EACCESS':
                buttons.push([
                    { text: 'üîë V√©rifier les acc√®s', callback_data: 'check_access' },
                    { text: 'üìû Contacter le support', callback_data: 'contact_support' }
                ]);
                break;

            case 'EFILE':
                buttons.push([
                    { text: 'üîÑ R√©essayer', callback_data: 'retry_upload' },
                    { text: 'üìã Voir les instructions', callback_data: 'upload_help' }
                ]);
                break;

            default:
                if (errorAnalysis.severity === 'high') {
                    buttons.push([
                        { text: 'üìû Contacter le support', callback_data: 'contact_support' }
                    ]);
                }
        }

        // Options pour le message
        const options = buttons.length > 0 ? {
            reply_markup: {
                inline_keyboard: buttons
            }
        } : undefined;

        // D√©terminer le chat ID et utiliser sendMessage au lieu de reply
        let chatId;
        
        if (ctx.chat) {
            chatId = ctx.chat.id;
        } else if (ctx.channelPost) {
            chatId = ctx.channelPost.chat.id;
        } else if (ctx.callbackQuery) {
            chatId = ctx.callbackQuery.message.chat.id;
        }

        if (!chatId) {
            throw new Error('Impossible de d√©terminer le chat ID');
        }

        // Envoyer la r√©ponse en utilisant ctx.telegram.sendMessage
        await ctx.telegram.sendMessage(chatId, message, options);

    } catch (error) {
        logger.error('Erreur lors de l\'envoi de la r√©ponse:', error);
        
        // Tenter une r√©ponse simplifi√©e en dernier recours
        try {
            // Utiliser sendMessage avec le chat ID si disponible
            if (ctx.chat?.id) {
                await ctx.telegram.sendMessage(ctx.chat.id, 'Une erreur est survenue. Veuillez r√©essayer plus tard.');
            } else if (ctx.channelPost?.chat.id) {
                await ctx.telegram.sendMessage(ctx.channelPost.chat.id, 'Une erreur est survenue. Veuillez r√©essayer plus tard.');
            }
        } catch (finalError) {
            logger.error('√âchec de la r√©ponse finale:', finalError);
        }
    }
}

// Nettoyer apr√®s l'erreur si n√©cessaire
async function cleanup(errorAnalysis, ctx) {
    if (!errorAnalysis.needsCleanup) return;

    try {
        // Nettoyer la session si n√©cessaire
        if (ctx.session) {
            // Sauvegarder certaines informations importantes
            const importantData = {
                user: ctx.session.user,
                lastActivity: ctx.session.lastActivity
            };

            // R√©initialiser la session
            ctx.session = {
                ...importantData,
                restored: true,
                lastError: {
                    type: errorAnalysis.type,
                    timestamp: errorAnalysis.timestamp
                }
            };
        }

        // Nettoyer les fichiers temporaires si n√©cessaire
        if (errorAnalysis.type === 'EFILE') {
            await cleanupTempFiles(ctx);
        }

        // Annuler les op√©rations en cours si n√©cessaire
        if (ctx.session?.currentOperation) {
            await cancelCurrentOperation(ctx);
        }

    } catch (error) {
        logger.error('Erreur lors du nettoyage:', error);
    }
}

// Nettoyer les fichiers temporaires
async function cleanupTempFiles(ctx) {
    try {
        const fs = require('fs').promises;
        const path = require('path');

        if (ctx.session?.tempFiles) {
            for (const filePath of ctx.session.tempFiles) {
                try {
                    await fs.unlink(path.join(__dirname, '../temp', filePath));
                } catch (error) {
                    logger.error('Erreur lors de la suppression du fichier:', {
                        filePath,
                        error
                    });
                }
            }
            delete ctx.session.tempFiles;
        }
    } catch (error) {
        logger.error('Erreur lors du nettoyage des fichiers:', error);
    }
}

// Annuler l'op√©ration en cours
async function cancelCurrentOperation(ctx) {
    try {
        const operation = ctx.session.currentOperation;

        switch (operation?.type) {
            case 'payment':
                await cancelPayment(operation.paymentId);
                break;
            case 'order':
                await cancelOrder(operation.orderId);
                break;
            case 'upload':
                await cancelUpload(operation.uploadId);
                break;
            // Ajouter d'autres cas selon les besoins
        }

        delete ctx.session.currentOperation;
    } catch (error) {
        logger.error('Erreur lors de l\'annulation de l\'op√©ration:', error);
    }
}

// G√©n√©rer une r√©f√©rence d'erreur unique
function generateErrorReference() {
    const timestamp = Date.now().toString(36);
    const random = Math.random().toString(36).substring(2, 7);
    return `ERR-${timestamp}-${random}`.toUpperCase();
}

// Fonctions d'annulation sp√©cifiques
async function cancelPayment(paymentId) {
    try {
        const Payment = require('../models/Payment');
        await Payment.findByIdAndUpdate(paymentId, {
            status: 'cancelled',
            cancelledAt: new Date(),
            cancellationReason: 'Erreur syst√®me'
        });
    } catch (error) {
        logger.error('Erreur lors de l\'annulation du paiement:', error);
    }
}

async function cancelOrder(orderId) {
    try {
        const Order = require('../models/Order');
        await Order.findByIdAndUpdate(orderId, {
            status: 'cancelled',
            cancelledAt: new Date(),
            cancellationReason: 'Erreur syst√®me'
        });
    } catch (error) {
        logger.error('Erreur lors de l\'annulation de la commande:', error);
    }
}

async function cancelUpload(uploadId) {
    try {
        const Upload = require('../models/Upload');
        await Upload.findByIdAndUpdate(uploadId, {
            status: 'cancelled',
            cancelledAt: new Date(),
            cancellationReason: 'Erreur syst√®me'
        });
    } catch (error) {
        logger.error('Erreur lors de l\'annulation de l\'upload:', error);
    }
}

module.exports = errorHandler;